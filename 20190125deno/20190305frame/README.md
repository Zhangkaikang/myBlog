# 如何构建一个同时支持node和deno的框架
这篇文章，我更倾向于在分享自己的对构建多运行时框架构建思想，同时希望能够听取更多人的想法，构建更好的过渡框架。

# 最初想法
最初想法是收到wine的启发，直接用deno实现一套node的api，然后通过这个api来实现node程序在deno运行的无缝切换。但实现了一段时间后，发现存在几个问题。
* 工作量较大，每一次API不断出现，每次都要重新移植
* 不仅仅要支持deno,支持deno只是解决当前问题，后面可能会出现oden,enod等等
* 细节上很难做好，由于毕竟是两套实现，所以在细节上，始终很难保持一致
* 历史包袱将不断扩大，这会把node的历史问题带给下一个运行时

所以这个想法，在实现过程中和深思中发现并不是一个好方案，所以快速冷静下来，思考一个更好的解决方案。

# 新的想法
吸取教训后，痛定思痛。发现要完全丝滑迁移是不现实的，只能考虑保证新的产品能够更加无损的切换，只保证新的框架不会受到老框架的影响。

所以新点子出现，自己写一个中间层来支持，业务逻辑里面只需要写原生JS代码，不需要写node或者deno的代码不就好了。那么对比最初的方案优点缺点，我归类了一下：
优点：
1. 工作量偏小
2. 即使后续推出新的运行时，依旧可以较好的支持
3. 依赖自己实现的中间层，所以不受制运行时影响导致细节差别过大问题
4. 业务代码只写JS，不会把上一个运行时的历史包袱，带给下一个运行时

缺点：
* 只能在新业务中使用
* 库只能自己通过中间层暴露的接口重新实现一遍

# 付出实践
整理并简化实现中。。。请稍等

# 最后聊聊
由于这是做的一个DEMO，所以很多都采取了极简模式，包括控制器和服务层都没有基类，模型层直接忽略了，没有使用工厂化生产控制器和服务层等等，同时路由目前连参数也不支持。但是对于这次关于同时兼容node和deno的服务框架的，考虑应该也是足够的。

思想包括，但不限于：
* 即使存在新的运行时，只要重新实现一遍中间层功能即可
* 使用不同入口，但可以从入口保证最终实现的功能相同
* 使用注入的方式，从暴露的中间层变量，如果使用JS之外的方法，包括http和文件读取，保证除中间层外只允许纯JS使用

最后希望大家能给出一些思想上的一些帮助而非代码层面，谢谢