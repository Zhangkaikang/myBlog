# 觉醒js计算能力，浅谈加密学之椭圆加密算法
上一节谈了[《Bitcoin公私钥是如何生成的》](https://github.com/zy445566/myBlog/blob/master/20190529bitcoin/20190529bitcoin-key-gen/README.md),并简单聊了下椭圆加密算法的标量运算，但是很多计算机实现密码学过程中的算法细节都没有谈，今天我们来谈一谈，并且用js的新能力BigInt来从零实现ecdsa-secp256k1。

# 0x01我们要用椭圆加密算法干什么？
可能很多人只知道Bitcoin钱包的核心是椭圆加密算法，但是椭圆加密算法能干什么却不是很清楚。

举个栗子，小明给小红开了一张一百万的支票，小红拿着支票去银行兑换，银行要验证支票是否真伪，首先要看支票是不是由该银行的发行的，第二要看支票的签名是否是本人，确定后才能给予了小红一百万。

在数字世界又该如何实现呢？
* 首先小明通过自己的身份去银行申请到了支票
    * 这就像私钥可以通过算法生成公钥。
* 其次小明在支票上签名生成一个有效的支票
    * 这就像利用签名算法生成了一个有效签名数据。
* 银行要验证支票是不是由该银行的发行和该签名是否是本人
    * 这就像利用验证算法通过公钥和签名数据验证签名是否有效

而这些利用椭圆加密算法就能做到。

# 0x02如何生成私钥又如何产生公钥
`注意：下文提到的p,a,b,G,N都是常量，你可以简单的认为是某个数字`

私钥可以从1到N中选择一个值作为私钥(k)，而公钥(K)的算法是K = kG,难道是k乘G？当然不是。这里的乘是标量乘法。

## 那么何为`标量乘法`呢？
简单来说即是kG只能由另外两个点叠加而成。
比如k等于14，我们只知道常量G,那么要叠加到14G是不是要这样(如下):
```
G+G = 2G
2G+G = 3G
3G+G = 4G
...
13G+G=14G
```
那有意思了，那如果k很大要怎么办呢？其实很简单，我们只要对折运算就好了。
先把14转换成二进制即是1110，那是不是相当于是(如下):
```
1110:
=>1*(2^3)G+1*(2^2)G+1*(2^1)G+0*(2^0)G
=> 1*8G + 1*4G + 1*2G + 0*G 
那么二进制只有4位就只要先计算4-1次,然后再相加不就好了
G+G = 2G
2G+2G = 4G
4G+4G = 8G
然后
2G+4G = 6G
6G+8G = 14G
```
对比挨个G相加，14要加13次，而下面这种只要相加5次，是不是就少了很多。当然越大的数，少的次数就越多。比如10000要相加9999次，而用优化后的方法10000只要相加17次就能得到结果。这个优化是极度恐怖的。

## 说完标量乘法我们来看看具体G是如何相加的
首先G相加更具推导公司分两种情况，我们用武功秘籍的方法来相称吧，以下：
```
相同的点相加第一式: λ≡(3x1^2+ a)/2y1(mod p)
相同的点相加第二式: x3 ≡ λ^2 − 2x1 (mod p), y3≡ λ(x1 − x3) − y1 (mod p)

不同的点相加第一式: λ≡ （y2 − y1）/（x2 − x1）(mod p)
不同的点相加第二式: x3 ≡ λ^2 − x1 − x2 (mod p), y3 ≡ λ(x1 − x3) − y1 (mod p)
```
即相同点。。。。不相同点。。。。

但这里又有一个问题了，除法如何计算保证不会有余，如何保证数学公式计算值的准确性？

# 未完待续！


# 附录
事例代码地址：[点此打开ecdsa-secp256k1实例代码](https://github.com/zy445566/ecdsa-secp256k1)
